
structure A = Absyn

%%

%term
    EOF
  | INT of int
  | PLUS
  | MINUS
  | TIMES
  | DIVIDE
  | EQ
  | GT
  | GE
  | LT
  | LE
  | LPAREN
  | RPAREN
  | LET
  | VAR
  | ASSIGN
  | IN
  | END
  | ID of string

%nonterm
    program of A.exp
  | exp of A.exp
  | dec of A.dec
  | decs of A.dec list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%keyword LET VAR IN END

%nonassoc EQ GT GE LT LE

%left PLUS MINUS
%left TIMES DIVIDE

%name Tiger

%%

program: exp                (exp)
decs: dec                   ([dec])
    | dec decs              (dec :: decs)
dec: VAR ID ASSIGN exp      (A.VarDec {symbol = Symbol.createSymbol ID, init = exp, pos = VARright})
exp: ID                     (A.VarExp (A.SimpleVar (Symbol.createSymbol ID, IDleft)))
   | INT                    (A.IntExp INT)
   | MINUS exp              (A.OpExp {left = A.IntExp 0, oper = A.MinusOp, right = exp, pos = MINUSright})
   | exp PLUS exp           (A.OpExp {left = exp1, oper = A.PlusOp, right = exp2, pos = PLUSleft})
   | exp MINUS exp          (A.OpExp {left = exp1, oper = A.MinusOp, right = exp2, pos = MINUSleft})
   | exp TIMES exp          (A.OpExp {left = exp1, oper = A.TimesOp, right = exp2, pos = TIMESleft})
   | exp DIVIDE exp         (A.OpExp {left = exp1, oper = A.DivideOp, right = exp2, pos = DIVIDEleft})
   | exp EQ exp             (A.OpExp {left = exp1, oper = A.EqOp, right = exp2, pos = EQleft})
   | exp LT exp             (A.OpExp {left = exp1, oper = A.LtOp, right = exp2, pos = LTleft})
   | exp LE exp             (A.OpExp {left = exp1, oper = A.LeOp, right = exp2, pos = LEleft})
   | exp GT exp             (A.OpExp {left = exp1, oper = A.GtOp, right = exp2, pos = GTleft})
   | exp GE exp             (A.OpExp {left = exp1, oper = A.GeOp, right = exp2, pos = GEleft})
   | LPAREN exp RPAREN      (exp)
   | LET decs IN exp END    (A.LetExp {decs = decs, body = exp, pos = LETright})
